
test_multiplexer.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000348  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00802000  00000348  000003bc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .stab         00000714  00000000  00000000  000003bc  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000097  00000000  00000000  00000ad0  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .comment      0000002f  00000000  00000000  00000b67  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 00000028  00000000  00000000  00000b96  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000004ca  00000000  00000000  00000bbe  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000178  00000000  00000000  00001088  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000186  00000000  00000000  00001200  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000a4  00000000  00000000  00001388  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000304  00000000  00000000  0000142c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000114  00000000  00000000  00001730  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000050  00000000  00000000  00001844  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 fa 00 	jmp	0x1f4	; 0x1f4 <__ctors_end>
   4:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
   8:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
   c:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  10:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  14:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  18:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  1c:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  20:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  24:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  28:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  2c:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  30:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  34:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  38:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  3c:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  40:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  44:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  48:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  4c:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  50:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  54:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  58:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  5c:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  60:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  64:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  68:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  6c:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  70:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  74:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  78:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  7c:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  80:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  84:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  88:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  8c:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  90:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  94:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  98:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  9c:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  a0:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  a4:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  a8:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  ac:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  b0:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  b4:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  b8:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  bc:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  c0:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  c4:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  c8:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  cc:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  d0:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  d4:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  d8:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  dc:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  e0:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  e4:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  e8:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  ec:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  f0:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  f4:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  f8:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
  fc:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 100:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 104:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 108:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 10c:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 110:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 114:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 118:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 11c:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 120:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 124:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 128:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 12c:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 130:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 134:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 138:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 13c:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 140:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 144:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 148:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 14c:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 150:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 154:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 158:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 15c:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 160:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 164:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 168:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 16c:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 170:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 174:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 178:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 17c:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 180:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 184:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 188:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 18c:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 190:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 194:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 198:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 19c:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 1a0:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 1a4:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 1a8:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 1ac:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 1b0:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 1b4:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 1b8:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 1bc:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 1c0:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 1c4:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 1c8:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 1cc:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 1d0:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 1d4:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 1d8:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 1dc:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 1e0:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 1e4:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 1e8:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 1ec:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
 1f0:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>

000001f4 <__ctors_end>:
 1f4:	11 24       	eor	r1, r1
 1f6:	1f be       	out	0x3f, r1	; 63
 1f8:	cf ef       	ldi	r28, 0xFF	; 255
 1fa:	df e3       	ldi	r29, 0x3F	; 63
 1fc:	de bf       	out	0x3e, r29	; 62
 1fe:	cd bf       	out	0x3d, r28	; 61
 200:	00 e0       	ldi	r16, 0x00	; 0
 202:	0c bf       	out	0x3c, r16	; 60
 204:	18 be       	out	0x38, r1	; 56
 206:	19 be       	out	0x39, r1	; 57
 208:	1a be       	out	0x3a, r1	; 58
 20a:	1b be       	out	0x3b, r1	; 59
 20c:	0e 94 70 01 	call	0x2e0	; 0x2e0 <main>
 210:	0c 94 a2 01 	jmp	0x344	; 0x344 <_exit>

00000214 <__bad_interrupt>:
 214:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000218 <setup_channel_select_pins>:

/** \brief Sets up the channel select pins.
 *
 * GPIO pins [0..3] on header J3 are used to select multiplexer channel. */
void setup_channel_select_pins(void) {
   CHANNEL_PORT.DIR |= CHANNEL_PINS_bm;   // set channel select pins to out
 218:	e0 e6       	ldi	r30, 0x60	; 96
 21a:	f6 e0       	ldi	r31, 0x06	; 6
 21c:	80 81       	ld	r24, Z
 21e:	8f 60       	ori	r24, 0x0F	; 15
 220:	80 83       	st	Z, r24
   CHANNEL_PORT.OUTCLR = CHANNEL_PINS_bm; // set to channel 0 initially
 222:	8f e0       	ldi	r24, 0x0F	; 15
 224:	86 83       	std	Z+6, r24	; 0x06
 226:	08 95       	ret

00000228 <setup_leds>:

/** \brief Sets up the LEDS.
 *
 * LEDS[0..3] read out the binary value of the current channel selection */
void setup_leds(void) {
   LEDPORT.DIR = 0xff;                 // set all pins of port E to output
 228:	e0 e8       	ldi	r30, 0x80	; 128
 22a:	f6 e0       	ldi	r31, 0x06	; 6
 22c:	8f ef       	ldi	r24, 0xFF	; 255
 22e:	80 83       	st	Z, r24
   PORTCFG.MPCMASK = 0xff;             // set for all pins on port E...
 230:	80 93 b0 00 	sts	0x00B0, r24
   LEDPORT.PIN0CTRL |= PORT_INVEN_bm;  // inverted output (set hi turns on led)
 234:	80 89       	ldd	r24, Z+16	; 0x10
 236:	80 64       	ori	r24, 0x40	; 64
 238:	80 8b       	std	Z+16, r24	; 0x10
   LEDPORT.OUTCLR = 0x00;              // turn all leds off
 23a:	16 82       	std	Z+6, r1	; 0x06
 23c:	08 95       	ret

0000023e <setup_switches>:

/** \brief Sets up the switches.
 *
 * Switch 7 cycles through multiplexer chanels 0..15 */
void setup_switches(void) {
   SWITCHPORTH.DIR &= ~CYCLE_SWITCH_bm;   // set the switch 7's pin as input
 23e:	e0 ee       	ldi	r30, 0xE0	; 224
 240:	f7 e0       	ldi	r31, 0x07	; 7
 242:	80 81       	ld	r24, Z
 244:	8d 7f       	andi	r24, 0xFD	; 253
 246:	80 83       	st	Z, r24
   SWITCHPORTH.PIN1CTRL |= PORT_OPC_PULLUP_gc;
 248:	81 89       	ldd	r24, Z+17	; 0x11
 24a:	88 61       	ori	r24, 0x18	; 24
 24c:	81 8b       	std	Z+17, r24	; 0x11
 24e:	08 95       	ret

00000250 <setup_signal_pin>:
/** \brief Sets up the signal reading pin
 *
 * GPIO pin 4 on header J3 is used to read the value on the signal pin of the
 * multiplexer */
void setup_signal_pin(void) {
   SIGNAL_PORT.DIR &= ~SIGNAL_PIN_bm; // set the signal pin as an input
 250:	e0 e6       	ldi	r30, 0x60	; 96
 252:	f6 e0       	ldi	r31, 0x06	; 6
 254:	80 81       	ld	r24, Z
 256:	8f 7e       	andi	r24, 0xEF	; 239
 258:	80 83       	st	Z, r24
   SIGNAL_PORT.PIN4CTRL |= PORT_OPC_PULLDOWN_gc;
 25a:	84 89       	ldd	r24, Z+20	; 0x14
 25c:	80 61       	ori	r24, 0x10	; 16
 25e:	84 8b       	std	Z+20, r24	; 0x14
 260:	08 95       	ret

00000262 <setup>:

/** \brief Sets up the channel select pins.
 *
 * GPIO pins [0..3] on header J3 are used to select multiplexer channel. */
void setup_channel_select_pins(void) {
   CHANNEL_PORT.DIR |= CHANNEL_PINS_bm;   // set channel select pins to out
 262:	e0 e6       	ldi	r30, 0x60	; 96
 264:	f6 e0       	ldi	r31, 0x06	; 6
 266:	80 81       	ld	r24, Z
 268:	8f 60       	ori	r24, 0x0F	; 15
 26a:	80 83       	st	Z, r24
   CHANNEL_PORT.OUTCLR = CHANNEL_PINS_bm; // set to channel 0 initially
 26c:	8f e0       	ldi	r24, 0x0F	; 15
 26e:	86 83       	std	Z+6, r24	; 0x06

/** \brief Sets up the LEDS.
 *
 * LEDS[0..3] read out the binary value of the current channel selection */
void setup_leds(void) {
   LEDPORT.DIR = 0xff;                 // set all pins of port E to output
 270:	a0 e8       	ldi	r26, 0x80	; 128
 272:	b6 e0       	ldi	r27, 0x06	; 6
 274:	8f ef       	ldi	r24, 0xFF	; 255
 276:	8c 93       	st	X, r24
   PORTCFG.MPCMASK = 0xff;             // set for all pins on port E...
 278:	80 93 b0 00 	sts	0x00B0, r24
   LEDPORT.PIN0CTRL |= PORT_INVEN_bm;  // inverted output (set hi turns on led)
 27c:	50 96       	adiw	r26, 0x10	; 16
 27e:	8c 91       	ld	r24, X
 280:	50 97       	sbiw	r26, 0x10	; 16
 282:	80 64       	ori	r24, 0x40	; 64
 284:	50 96       	adiw	r26, 0x10	; 16
 286:	8c 93       	st	X, r24
 288:	50 97       	sbiw	r26, 0x10	; 16
   LEDPORT.OUTCLR = 0x00;              // turn all leds off
 28a:	16 96       	adiw	r26, 0x06	; 6
 28c:	1c 92       	st	X, r1

/** \brief Sets up the switches.
 *
 * Switch 7 cycles through multiplexer chanels 0..15 */
void setup_switches(void) {
   SWITCHPORTH.DIR &= ~CYCLE_SWITCH_bm;   // set the switch 7's pin as input
 28e:	a0 ee       	ldi	r26, 0xE0	; 224
 290:	b7 e0       	ldi	r27, 0x07	; 7
 292:	8c 91       	ld	r24, X
 294:	8d 7f       	andi	r24, 0xFD	; 253
 296:	8c 93       	st	X, r24
   SWITCHPORTH.PIN1CTRL |= PORT_OPC_PULLUP_gc;
 298:	51 96       	adiw	r26, 0x11	; 17
 29a:	8c 91       	ld	r24, X
 29c:	51 97       	sbiw	r26, 0x11	; 17
 29e:	88 61       	ori	r24, 0x18	; 24
 2a0:	51 96       	adiw	r26, 0x11	; 17
 2a2:	8c 93       	st	X, r24
/** \brief Sets up the signal reading pin
 *
 * GPIO pin 4 on header J3 is used to read the value on the signal pin of the
 * multiplexer */
void setup_signal_pin(void) {
   SIGNAL_PORT.DIR &= ~SIGNAL_PIN_bm; // set the signal pin as an input
 2a4:	80 81       	ld	r24, Z
 2a6:	8f 7e       	andi	r24, 0xEF	; 239
 2a8:	80 83       	st	Z, r24
   SIGNAL_PORT.PIN4CTRL |= PORT_OPC_PULLDOWN_gc;
 2aa:	84 89       	ldd	r24, Z+20	; 0x14
 2ac:	80 61       	ori	r24, 0x10	; 16
 2ae:	84 8b       	std	Z+20, r24	; 0x14
 2b0:	08 95       	ret

000002b2 <show_channel>:

/** \brief Sets LEDS[0..3] to the binary value of the selected channel.
 *
 * \param channel which channel is currently selected */
void show_channel(int8_t channel) {
   LEDPORT.OUTCLR = CHANNEL_LEDS_bm;
 2b2:	e0 e8       	ldi	r30, 0x80	; 128
 2b4:	f6 e0       	ldi	r31, 0x06	; 6
 2b6:	9f e0       	ldi	r25, 0x0F	; 15
 2b8:	96 83       	std	Z+6, r25	; 0x06
   LEDPORT.OUTSET = channel;
 2ba:	85 83       	std	Z+5, r24	; 0x05
 2bc:	08 95       	ret

000002be <set_channel>:
 * Sets the channel select pins to change which channel is being read by the
 * multiplexer
 *
 * \param channel which channel to select */
void set_channel(int8_t channel) {
   CHANNEL_PORT.OUTCLR = CHANNEL_PINS_bm;
 2be:	e0 e6       	ldi	r30, 0x60	; 96
 2c0:	f6 e0       	ldi	r31, 0x06	; 6
 2c2:	9f e0       	ldi	r25, 0x0F	; 15
 2c4:	96 83       	std	Z+6, r25	; 0x06
   CHANNEL_PORT.OUTSET = channel & CHANNEL_PINS_bm;
 2c6:	8f 70       	andi	r24, 0x0F	; 15
 2c8:	85 83       	std	Z+5, r24	; 0x05
 2ca:	08 95       	ret

000002cc <show_signal>:

/* \brief LEDS[4..7] will be lit if signal evaluates to true.
 *
 * \param signal_present whether a signal is present. */
void show_signal(uint8_t signal_present) {
   if (signal_present) {
 2cc:	81 11       	cpse	r24, r1
 2ce:	04 c0       	rjmp	.+8      	; 0x2d8 <show_signal+0xc>
      LEDPORT.OUTSET = SIGNAL_LEDS_bm;
   }
   else  {
      LEDPORT.OUTCLR = SIGNAL_LEDS_bm;
 2d0:	80 ef       	ldi	r24, 0xF0	; 240
 2d2:	80 93 86 06 	sts	0x0686, r24
 2d6:	08 95       	ret
/* \brief LEDS[4..7] will be lit if signal evaluates to true.
 *
 * \param signal_present whether a signal is present. */
void show_signal(uint8_t signal_present) {
   if (signal_present) {
      LEDPORT.OUTSET = SIGNAL_LEDS_bm;
 2d8:	80 ef       	ldi	r24, 0xF0	; 240
 2da:	80 93 85 06 	sts	0x0685, r24
 2de:	08 95       	ret

000002e0 <main>:

int main(void) {
   int8_t channel = 0;
   bool pushed = 0;

   setup();
 2e0:	0e 94 31 01 	call	0x262	; 0x262 <setup>
   }
}

int main(void) {
   int8_t channel = 0;
   bool pushed = 0;
 2e4:	90 e0       	ldi	r25, 0x00	; 0
      LEDPORT.OUTCLR = SIGNAL_LEDS_bm;
   }
}

int main(void) {
   int8_t channel = 0;
 2e6:	20 e0       	ldi	r18, 0x00	; 0
 * Sets the channel select pins to change which channel is being read by the
 * multiplexer
 *
 * \param channel which channel to select */
void set_channel(int8_t channel) {
   CHANNEL_PORT.OUTCLR = CHANNEL_PINS_bm;
 2e8:	4f e0       	ldi	r20, 0x0F	; 15
void show_signal(uint8_t signal_present) {
   if (signal_present) {
      LEDPORT.OUTSET = SIGNAL_LEDS_bm;
   }
   else  {
      LEDPORT.OUTCLR = SIGNAL_LEDS_bm;
 2ea:	30 ef       	ldi	r19, 0xF0	; 240

   setup();

   while (1)
   {
      if (!pushed && (SWITCHPORTH.IN & CYCLE_SWITCH_bm)) {
 2ec:	80 91 e8 07 	lds	r24, 0x07E8
 2f0:	99 23       	and	r25, r25
 2f2:	61 f0       	breq	.+24     	; 0x30c <main+0x2c>
         }
         set_channel(++channel);
         show_channel(channel);
         pushed = 1;
      }
      else if (pushed && (SWITCHPORTH.IN & CYCLE_SWITCH_bm) == 0) {
 2f4:	81 ff       	sbrs	r24, 1
         pushed = 0;
 2f6:	90 e0       	ldi	r25, 0x00	; 0
      }
      show_signal(SIGNAL_PORT.IN & SIGNAL_PIN_bm);
 2f8:	80 91 68 06 	lds	r24, 0x0668

/* \brief LEDS[4..7] will be lit if signal evaluates to true.
 *
 * \param signal_present whether a signal is present. */
void show_signal(uint8_t signal_present) {
   if (signal_present) {
 2fc:	84 ff       	sbrs	r24, 4
 2fe:	1b c0       	rjmp	.+54     	; 0x336 <main+0x56>
      LEDPORT.OUTSET = SIGNAL_LEDS_bm;
 300:	30 93 85 06 	sts	0x0685, r19

   setup();

   while (1)
   {
      if (!pushed && (SWITCHPORTH.IN & CYCLE_SWITCH_bm)) {
 304:	80 91 e8 07 	lds	r24, 0x07E8
 308:	91 11       	cpse	r25, r1
 30a:	f4 cf       	rjmp	.-24     	; 0x2f4 <main+0x14>
 30c:	81 ff       	sbrs	r24, 1
 30e:	f4 cf       	rjmp	.-24     	; 0x2f8 <main+0x18>
         if (channel == 15) {
 310:	2f 30       	cpi	r18, 0x0F	; 15
 312:	a1 f0       	breq	.+40     	; 0x33c <main+0x5c>
 314:	2f 5f       	subi	r18, 0xFF	; 255
 316:	92 2f       	mov	r25, r18
 318:	9f 70       	andi	r25, 0x0F	; 15
 31a:	82 2f       	mov	r24, r18
 * Sets the channel select pins to change which channel is being read by the
 * multiplexer
 *
 * \param channel which channel to select */
void set_channel(int8_t channel) {
   CHANNEL_PORT.OUTCLR = CHANNEL_PINS_bm;
 31c:	40 93 66 06 	sts	0x0666, r20
   CHANNEL_PORT.OUTSET = channel & CHANNEL_PINS_bm;
 320:	90 93 65 06 	sts	0x0665, r25

/** \brief Sets LEDS[0..3] to the binary value of the selected channel.
 *
 * \param channel which channel is currently selected */
void show_channel(int8_t channel) {
   LEDPORT.OUTCLR = CHANNEL_LEDS_bm;
 324:	40 93 86 06 	sts	0x0686, r20
   LEDPORT.OUTSET = channel;
 328:	80 93 85 06 	sts	0x0685, r24
         if (channel == 15) {
            channel = -1;
         }
         set_channel(++channel);
         show_channel(channel);
         pushed = 1;
 32c:	91 e0       	ldi	r25, 0x01	; 1
      }
      else if (pushed && (SWITCHPORTH.IN & CYCLE_SWITCH_bm) == 0) {
         pushed = 0;
      }
      show_signal(SIGNAL_PORT.IN & SIGNAL_PIN_bm);
 32e:	80 91 68 06 	lds	r24, 0x0668

/* \brief LEDS[4..7] will be lit if signal evaluates to true.
 *
 * \param signal_present whether a signal is present. */
void show_signal(uint8_t signal_present) {
   if (signal_present) {
 332:	84 fd       	sbrc	r24, 4
 334:	e5 cf       	rjmp	.-54     	; 0x300 <main+0x20>
      LEDPORT.OUTSET = SIGNAL_LEDS_bm;
   }
   else  {
      LEDPORT.OUTCLR = SIGNAL_LEDS_bm;
 336:	30 93 86 06 	sts	0x0686, r19
 33a:	d8 cf       	rjmp	.-80     	; 0x2ec <main+0xc>
   setup();

   while (1)
   {
      if (!pushed && (SWITCHPORTH.IN & CYCLE_SWITCH_bm)) {
         if (channel == 15) {
 33c:	80 e0       	ldi	r24, 0x00	; 0
 33e:	90 e0       	ldi	r25, 0x00	; 0
 340:	20 e0       	ldi	r18, 0x00	; 0
 342:	ec cf       	rjmp	.-40     	; 0x31c <main+0x3c>

00000344 <_exit>:
 344:	f8 94       	cli

00000346 <__stop_program>:
 346:	ff cf       	rjmp	.-2      	; 0x346 <__stop_program>
